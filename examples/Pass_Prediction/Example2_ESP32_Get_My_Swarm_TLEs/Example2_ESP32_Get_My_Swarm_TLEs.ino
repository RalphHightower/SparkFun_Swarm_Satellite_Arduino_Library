/*
  Use ESP32 WiFi to get the Two-Line Elements for the Swarm satellites
  By: SparkFun Electronics / Paul Clark
  Date: July 31st, 2022
  License: MIT. See license file for more information but you can
  basically do whatever you want with this code.

  ** If you have enjoyed this code, please consider making a donation to CelesTrak: https://celestrak.org/ **

  This example shows how to:
    * Download the list of Two-Line Elements (orbit parameters) for the Swarm satellites which cover your location
  
  You can then use the TLEs to predict the next satellite pass for your location - offline!

  This example uses the list of satellites (mySwarm.txt) generated by the previous example.
  The TLEs are downloaded individually from CelesTrak based on their NORAD catalog numbers.
  
  Example3 uses the TLE data to predict the next pass: Example3_ESP32_Predict_Next_Swarm_Pass
  
  Update secrets.h with your:
  - WiFi credentials

  This example is written for the SparkFun Thing Plus C but can be adapted for any ESP32 board.

  If the SD card is not detected ("Card Mount Failed"), try adding a 10K pull-up resistor between 19/POCI and 3V3.

  Feel like supporting open source hardware?
  Buy a board from SparkFun!
  SparkFun Thing Plus C - ESP32 WROOM

*/

#include <FS.h>
#include <SD.h>
#include <SPI.h>

#define sd_cs SS // microSD chip select - this should work on most boards
//const int sd_cs = 5; //Uncomment this line to define a specific pin for the chip select (e.g. pin 5 on the Thing Plus C)

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include <WiFi.h>
#include <HTTPClient.h>
#include "secrets.h"

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include "SWARM_NORAD.h"

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// The Two-Line Element orbit data will be downloaded from CelesTrak

const char celestrakServer[] = "https://celestrak.org";

const char getSwarmTLE[] = "NORAD/elements/gp.php?CATNR=";
const char getSwarmTLEsuffix[] = "&FORMAT=tle";

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

void setup()
{
  delay(1000);

  Serial.begin(115200);
  Serial.println(F("Example : Swarm Two-Line Elements for your location"));

  while (Serial.available()) Serial.read(); // Empty the serial buffer
  Serial.println(F("Press any key to begin..."));
  while (!Serial.available()); // Wait for a keypress
  Serial.println();

  //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  // Connect to WiFi.

  Serial.print(F("Connecting to local WiFi"));

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(F("."));
  }
  Serial.println();

  Serial.println(F("WiFi connected!"));

  HTTPClient http;
  int httpCode;
      
  //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  // Open mySwarm.txt for reading. Open mySwmTLE.txt for writing.

  if (!SD.begin(sd_cs)) {
    Serial.println("Card Mount Failed! Freezing...");
    while (1)
      ;
  }

  File swarmFile = SD.open("/mySwarm.txt", FILE_READ);

  if (!swarmFile)
  {
    Serial.println("File Open Failed! Freezing...");
    while (1)
      ;
  }

  File myTleFile = SD.open("/mySwmTLE.txt", FILE_WRITE);

  if (!myTleFile) {
    Serial.println("File Open Failed! Freezing...");
    while (1)
      ;
  }

  //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  // Read each satellite name from mySwarm.txt, get its NORAD number,
  // request the TLE, write it to mySwmTLE.txt

  bool keepGoing = true;
  
  while (keepGoing)
  {

    // Allocate 30 bytes to store the satellite name
    char satelliteName[30];
    for (int i = 0; i < 30; i++)
      satelliteName[i] = 0;

    // Read the satellite name
    int satNameLength = swarmFile.readBytesUntil('\n', (char *)satelliteName, 30);

    if (satNameLength < 10)
    {
      keepGoing = false;
    }
    else
    {
      satelliteName[satNameLength - 1] = ' '; // Terminate the name - change the \r to ' '
      satelliteName[satNameLength] = 0; // Null-terminate the name

      int satNum = 0; // Record the satellite number
      bool isBeeNZ = false; // Record if this is a SPACEBEENZ
      
      if (satelliteName[8] == '-') // Look for SPACEBEE-nnn
      {
        satNum = satelliteName[9] - '0'; // Extract the satellite number (max 99999)
        if ((satelliteName[10] >= '0') && (satelliteName[10] <= '9'))
        {
          satNum *= 10;
          satNum += satelliteName[10] - '0';
          if ((satelliteName[11] >= '0') && (satelliteName[11] <= '9'))
          {
            satNum *= 10;
            satNum += satelliteName[11] - '0';
            if ((satelliteName[12] >= '0') && (satelliteName[12] <= '9'))
            {
              satNum *= 10;
              satNum += satelliteName[12] - '0';
              if ((satelliteName[13] >= '0') && (satelliteName[13] <= '9'))
              {
                satNum *= 10;
                satNum += satelliteName[13] - '0';
              }
            }
          }
        }
      }
      else if ((satelliteName[8] == 'N') && (satelliteName[9] == 'Z')) // Look for SPACEBEENZ-nnn
      {
        isBeeNZ = true;
        satNum = satelliteName[11] - '0'; // Extract the satellite number (max 99999)
        if ((satelliteName[12] >= '0') && (satelliteName[12] <= '9'))
        {
          satNum *= 10;
          satNum += satelliteName[12] - '0';
          if ((satelliteName[13] >= '0') && (satelliteName[13] <= '9'))
          {
            satNum *= 10;
            satNum += satelliteName[13] - '0';
            if ((satelliteName[14] >= '0') && (satelliteName[14] <= '9'))
            {
              satNum *= 10;
              satNum += satelliteName[14] - '0';
              if ((satelliteName[15] >= '0') && (satelliteName[15] <= '9'))
              {
                satNum *= 10;
                satNum += satelliteName[15] - '0';
              }
            }
          }
        }
      }

      //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      // Look up the NORAD number

      int NORAD = 0;
      if (!isBeeNZ) // Is this a regular Bee?
      {
        if (satNum <= maxSwarmNORAD)
          NORAD = swarmNORAD[satNum];
      }
      else
      {
        if (satNum <= maxSwarmNZNORAD)
          NORAD = swarmNZNORAD[satNum];
      }
      
      
      if (NORAD > 0)
      {
      
        //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Use HTTP GET to receive the TLE data
      
        const int URL_BUFFER_SIZE  = 256;
        char theURL[URL_BUFFER_SIZE]; // This will contain the HTTP URL
        int payloadSize = 0; // This will be updated with the length of the data we get from the server
        String payload = ""; // This will store the data we get from the server
      
        // Assemble the URL
        // Note the slash after the first %s (celestrakServer)
        snprintf(theURL, URL_BUFFER_SIZE, "%s/%s%d%s",
          celestrakServer,
          getSwarmTLE,
          NORAD,
          getSwarmTLEsuffix);
      
        Serial.println(F("Requesting the Swarm TLE data from CelesTrak"));
        Serial.print(F("HTTP URL is: "));
        Serial.println(theURL);
      
        http.begin(theURL);
      
        httpCode = http.GET(); // HTTP GET
      
        // httpCode will be negative on error
        if(httpCode > 0)
        {
          // HTTP header has been sent and Server response header has been handled
          Serial.printf("[HTTP] GET... code: %d\r\n", httpCode);
        
          // If the GET was successful, read the data
          if(httpCode == HTTP_CODE_OK) // Check for code 200
          {
            payloadSize = http.getSize();
            Serial.printf("Server returned %d bytes\r\n", payloadSize);
            
            payload = http.getString(); // Get the payload
      
            // Print the payload
            //for(int i = 0; i < payloadSize; i++)
            //{
            //  Serial.write(payload[i]);
            //}
          }
        }
        else
        {
          Serial.printf("[HTTP] GET... failed, error: %s\r\n", http.errorToString(httpCode).c_str());
        }
      
        //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Write the TLE data to SD card
      
        myTleFile.write((const uint8_t *)payload.c_str(), (size_t)payloadSize); // Write the payload to file

      }
    }
  }

  //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  // Disconnect the WiFi as it's no longer needed

  http.end();
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  Serial.println();
  Serial.println(F("WiFi disconnected"));

  //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  // Close the files

  myTleFile.close();
  swarmFile.close();

  Serial.println();
  listDir(SD, "/", 0); // List the card directory to see if the files were written correctly

  Serial.println();
  Serial.println(F("\r\nAll done!"));
}
  
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

void loop()
{
  // Nothing to do here
}

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

void listDir(fs::FS &fs, const char * dirname, uint8_t levels) {
  Serial.printf("Listing directory: %s\n", dirname);

  File root = fs.open(dirname);
  if (!root) {
    Serial.println("Failed to open directory");
    return;
  }
  if (!root.isDirectory()) {
    Serial.println("Not a directory");
    return;
  }

  File file = root.openNextFile();
  while (file) {
    if (file.isDirectory()) {
      Serial.print("  DIR : ");
      Serial.println(file.name());
      if (levels) {
        listDir(fs, file.name(), levels - 1);
      }
    } else {
      Serial.print("  FILE: ");
      Serial.print(file.name());
      Serial.print("  SIZE: ");
      Serial.println(file.size());
    }
    file = root.openNextFile();
  }
}
